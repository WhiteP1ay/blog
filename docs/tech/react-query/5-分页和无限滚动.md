# 分页和无限滚动

## 分页请求

分页请求是指请求参数通常会携带`limit/page`的请求，而返回值通常也是这种结构

```JSON
{
  cur_page: 1,
  total: 500,
  data: []
}
```

似乎平常的`useQuery`可以完美解决分页的需求，但每次翻页都要看 Loading。导致页面抖动。

`placeholderData`的第一个参数是 prevData，我们可以利用这一点。让加载时不再渲染 loading 而是保留上一页的数据，配合一个简单的半透明滤镜效果表明正在加载就可以在保证有响应的同时减少页面抖动。

```tsx
const {data,isPlaceholderData} = useQuery({
	...,
	placeholderData: (prevData) => {
		return prevData
	}
})

//...some tsx code...
<ul style={{ opacity: isPlaceholderData ? 0.5 : 1}}>
 {data.map(item => <li>{item.name}</li>)}
</ul>
```

能做的还有很多：比如翻页按钮的 disabled 状态，应该在`isPlaceholderData`为`true`时禁用。

```tsx
const { isPlaceholderData } = useBooksQuery(sort, page);

const prevDisabled = page === 1 || page === data.total || isPlaceholderData;
const nextDisabled = page === data.total || isPlaceholderData;
```

还有结合上一课的`prefetch`，实现在翻页时预加载下一页的数据。

```tsx
const getBooksQueryOptions = (sort: string, page: number) => ({
  queryKey: ["books", sort, page],
  queryFn: () => fetchBooks(sort, page),
  staleTime: 1000 * 60 * 5,
});

const useBooksQuery = (sort: string, page: number) => {
  const queryClient = useQueryClient();

  // 预加载下一页
  useEffect(() => {
    queryClient.prefetchQuery(getBooksQueryOptions(sort, page + 1));
  }, [sort, page, queryClient]);

  return useQuery(getBooksQueryOptions(sort, page));
};
```

## 无限滚动

无限滚动通常是当用户滚动到底部时，自动加载下一页的数据。

```tsx
const { data, hasNextPage, fetchNextPage } = useInfiniteQuery({
  queryKey: ["books", sort],
  initialPageParam: 1,
  queryFn: ({ pageParam = 1 }) => fetchBooks(sort, pageParam),
  getNextPageParam: (lastPage, pages, lastPageParam) => {
    if (lastPage.cur_page === lastPage.total) {
      return undefined;
    }
    return lastPage.cur_page + 1;
  },
});

//...some tsx code...
<ul>
  {data.pages.map((page) => (
    <li>{page.data.map((item) => item.name)}</li>
  ))}
</ul>
<button onClick={() => fetchNextPage()} disabled={!hasNextPage}>
  Next Page
</button>
```

上述定义是不准确的，因为还有一种可能是用户向上滚动时，自动加载上一页的数据。所以无限滚动需要支持双向获取数据（比如获取聊天记录）

```tsx
useInfiniteQuery({
  queryKey: ["books", sort],
  initialPageParam: { page: 1 },
  queryFn: ({ pageParam = 1 }) => fetchBooks(sort, pageParam),
  getNextPageParam: ({ lastPage, allPages }) => {
    if (lastPage.cur_page === lastPage.total) {
      return undefined;
    }
    return { page: allPages.length + 1 };
  },
  getPreviousPageParam: ({ lastPage, allPages }) => {
    if (lastPage.cur_page === 1) {
      return undefined;
    }
    return { page: allPages.length - 1 };
  },
});
```
值得注意的是，如果是无限滚动的话，`refetch`将会触发所有页面的重新请求，而非仅触发当前页面的重新请求。这是因为当某一页数据发生变更，可能后续（或前面）的每一页都随着发生变更。