# 复杂查询

## 视图

视图就是保存好的 SELECT 语句。

`视图`存的是 SELECT 语句，而不是实际数据。所以视图会节省存储空间。

`参照视图`就是指执行 SELECT 语句，返回结果集。

把常用的查询语句存为视图，这样就不用每次写重复的 GROUP BY、ORDER BY、WHERE 等语句。

**注意项：**

- 视图不可以使用 ORDER BY 语句。 因为视图是虚拟表，表中的数据行都是没有顺序的。
- 视图的更新有一些限制。因为汇总的视图的更新是无法判断如何将数据插入到基表中的。

### 创建视图

```sql
CREATE VIEW 视图名称 (column1, column2, ...)
AS
SELECT 语句
```

### 使用视图

把视图看做虚拟表。本质上是执行了两步

1. 执行视图的 SELECT 语句，返回结果集。
2. 把结果集看做虚拟表，再执行 SELECT 语句。

```sql
SELECT * FROM 视图名称;
```

### 删除视图

```sql
DROP VIEW 视图名称;
```

### 多重视图

多重视图就是指基于视图创建的视图。

```sql
CREATE VIEW 视图名称 (column1, column2, ...)
AS
SELECT 语句
FROM 另一个视图
```

可以但不推荐。多重视图会降低 SQL 性能。

## 子查询

子查询是一次性的视图。

基于 SELECT 语句支持的嵌套能力，在 FROM 子句中再写一个 SELECT 语句。

会先执行子查询，再执行主查询。

子查询也可以嵌套子查询，但随着嵌套层级越来越深，SQL 的性能会越来越低。所以不推荐使用。

```sql
SELECT 语句
FROM (SELECT 语句) AS 子查询名称
```

### 标量子查询

`标量`是单一的意思。

标量子查询就是指**必须且只能返回一行一列结果，也就是必须返回一个值**的子查询。

因为必须返回一个值，所以可以用在`=`或者`<>`这样需要比较的场景。

> 例子： 查询出销售额大于平均销售额的商品。

```sql
SELECT name,sale_price
FROM Product
WHERE sale_price > (
	SELECT AVG(sale_price)
	FROM Product
)
```

因为不可以在 WHERE 语句中使用聚合函数，所以需要使用子查询。

也可以用在其他子句中，勇于参与逻辑运算。需要注意的是，子查询的返回结果必须是一个值。

### 关联子查询

特点是内层查询会引用外层查询的值。

> 假设要查询出销售额大于该种类平均销售额的商品。

```sql
SELECT name,sale_price
FROM Product AS P1
WHERE sale_price > (
	SELECT AVG(sale_price)
	FROM Product AS P2
	WHERE P1.product_type = P2.product_type
)
```

| 商品名 | 类型 | 价格 |
| ------ | ---- | ---- |
| 衬衫   | 衣服 | 1000 |
| 运动衫 | 衣服 | 2000 |
| 铅笔   | 文具 | 100  |

执行过程是这样的：

1. 拿到第一行"衬衫"：
   - P1 是衬衫这行数据（类型=衣服）
   - 子查询计算所有衣服类型的平均价
   - 判断 1000 是否大于衣服类平均价
2. 拿到第二行"运动衫"：
   - P1 变成运动衫这行数据（类型=衣服）
   - 子查询又重新计算衣服类平均价
   - 判断 2000 是否大于衣服类平均价
3. 拿到第三行"铅笔"：
   - P1 变成铅笔这行数据（类型=文具）
   - 子查询计算文具类平均价
   - 判断 100 是否大于文具类平均价

这种在细分的组内进行比较的查询，通常需要使用`关联子查询`。
