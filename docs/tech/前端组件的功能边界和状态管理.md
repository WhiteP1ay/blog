# 前端组件的功能边界和状态管理

我们都知道组件应该是纯的，无副作用的，幂等的，所以不应该在组件里引入 store。

我这里说的组件是指：一个按钮、一个对话弹窗、一个表单、一个表格。这些组件应该处理好自己的事：把外界传入的数据渲染出来、需要处理各种事件时再 emit 出去，交给外界处理。

比如：

- 按钮的文案、主题类型该由外界传入，点击事件就应该 emit 出去。

- 对话框的内容就应该由外界传入，弹出事件、关闭事件就应该 emit 出去。

- 表单的数据模型、数据值就应该由外界传入，提交事件就应该 emit 出去。

- 表格渲染的数据就应该由外界传入，各种交互事件就应该 emit 出去。

这套规范让我代码分层很清晰，且工作良好。但也让我发现维护困难：

- 组件接受的 props 越来越多。
- 页面在引入这些组件的同时，自身需要引入的hooks也越来越多。
- 组件保持了简洁，但页面的逻辑逐渐混乱。

我想做一个简单的比喻：组件成了永远长不大的孩子，一直等着喂奶喝。而页面在引入组件的时候不得不负责照顾这些孩子。

## container

有时候一个组件一个 props 都没有，但它就是可以解决你的需求，那它就是一个好组件。

这并不是说我要把 store 无节制的接入到各个组件，让状态处处使用、处处修改。而是说应该介于纯函数和滥用状态管理之间应该存在一个中间状态，一种约定。

它既不像无状态组件那么纯，又不像一个页面那样引入了大量处理逻辑。假定这类组件叫`container`。

接下来我将介绍两种`container`：内聚型和分类型。

## 内聚型container

内聚型`container`无论从设计思想还是实现方案都很像面向对象中的类。

然而为了将UI层和逻辑层剥离，"类"被拆分成了hooks和`jsx/vue/...`。hooks内部可能引入了状态管理，可能包含各种`setter`、`getter`、`action`。所有围绕同一个主题的相关联的功能都内聚到了一起，降低了维护难度。这种组件通常可以开箱即用。

```jsx
const ApplyForm = ()=>{
  const {nameValue,ageValue,handleNameChange,handleAgaeChange,handleSubmit} = useApplyForm()
  
  return <>
  	<Form>
  		<Input label="姓名"></Input>
    	<Input label="年龄"></Input>
    	<Button onClick={handleSubmit}>提交</Button>
  	</Form>
  </>
}
```

## 分类型container

分类型的container是一些无状态组件的集合。

举一个例子：

有一个功能丰富的表格页，表格每行数据都有若干个操作按钮。这些操作按钮的点击会对应一些弹窗。那么这个页面的代码看起来可能是这样的：

```jsx
const TablePage = (props) => {
  const { tableData, handleClick, flagA, flagB } = useTable();

  return (
    <>
      <Table data={tableData}>
        <ButtonA onClick={() => (flagA = true)}></ButtonA>
        <ButtonB onClick={() => (flagB = true)}></ButtonB>
        ...
      </Table>
      <DialogA show={flagA}></DialogA>
      <DialogB show={flagB}></DialogB>
      ...
    </>
  );
};
```

可以预见，随着功能越来越多，按钮的点击事件回调函数越来越多，类似`DialogA`的组件会越来越多，类似`flagA`的状态会越来越多。

此时应该做一下简单的分类：`DialogGroup`和`TableContainer`，一个针对各个弹窗，另一个集合了各种按钮。

```jsx
const DialogGroup = () => {
  const { flagA, flagB } = useDialogStore();

  return (
    <>
      <DialogA show={flagA}></DialogA>
      <DialogB show={flagB}></DialogB>
    	...
    </>
  );
};

const TableContainer = () => {
  const { flagA, flagB } = useDialogStore();
  const {tableData} = useTable()

  return (
    <Table data={tableData}>
      <ButtonA onClick={() => (flagA = true)}></ButtonA>
      <ButtonB onClick={() => (flagB = true)}></ButtonB>
      ...
    </Table>
  );
};
```

难以维护的表格页代码变成了这样，简洁、好维护。

```jsx
const TablePage = (props) => {
  return (
    <>
      <TableContainer />
      <DialogGroup />
    </>
  );
};
```

## 总结

项目目录里应该有一个新的文件夹：`container`，专门用来存放有状态组件。

`container`在开发过程中很常见，只是少有人会把它们从`components`或者`pages`里提取出来。

但我觉得提取出来是必要的，因为这明确了哪些是纯的，哪些是“脏的”。
